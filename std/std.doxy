class Void;

primitive Char {
    extern fn str (self) Str,

    extern fn == (self, other: Char) Bool,
    fn != (self, other: Char) Bool {
        return !(self == other)
    }
}

primitive Bool {
    fn str (self) Str {
        if self {
            return "true"
        }
        return "false"
    }

    extern fn || (self, other: Bool) Bool,
    extern fn && (self, other: Bool) Bool,
}

primitive Int {
    fn max (self, other: Int) Int {
        if self > other {
            return self
        }
        return other
    }
    fn min (self, other: Int) Int {
        if self < other {
            return self
        }
        return other
    }

    extern fn str (self) Str,

    extern fn +  (self, n: Int) Int,
    extern fn -  (self, n: Int) Int,
    extern fn *  (self, n: Int) Int,
    extern fn /  (self, n: Int) Int,
    extern fn %  (self, n: Int) Int,
    extern fn == (self, n: Int) Bool,
    extern fn != (self, n: Int) Bool,
    extern fn <  (self, n: Int) Bool,
    extern fn <= (self, n: Int) Bool,
    extern fn >  (self, n: Int) Bool,
    extern fn >= (self, n: Int) Bool,
}

class Str {
    fn str (self) Str {
        return self
    }
    fn concat (self, other: Str) Str {
        return self + other
    }
    fn repeat (self, n: Int) Str {
        if n < 1 {
            return ""
        }
        // TODO: helper function in assembly to do this without allocating
        //       a new string each time through the loop
        return self + self.repeat(n - 1)
    }

    extern fn at (self, i: Int) Char,
    extern fn at_raw (self, i: Int) Char,
    extern fn len (self) Int,

    fn contains (self, other: Str) Bool {
        return self.find(other) >= 0
    }
    fn find (self, other: Str) Int {
        if other.len() == 0 {
            return 0
        }
        let mut i = 0;
        while i < self.len() {
            if self.at(i) == other.at(0) {
                let mut j = 1;
                while j < other.len() && self.at(i + j) == other.at(j) {
                    j = j + 1
                }
                if j == other.len() {
                    return i
                }
            }
            i = i + 1
        }
        return -1
    }

//    fn substr (self, start: Int, end: Int) Str {
//        if start < 0 || end < 0 || start > end {
//            return ""
//        }
//        let actual_end = self.len().min(end);
//        let mut i = start;
//        let mut s = "";
//        while i < actual_end {
//            s = s + self.at_raw(i).str();
//            i = i + 1
//        }
//        return s
//    }

    extern fn == (self, other: Str) Bool,
    extern fn != (self, other: Str) Bool,
    extern fn +  (self, other: Str) Str,
}

extern fn print (msg: Str);
fn println (msg: Str, line_end="\n") {
    print(msg);
    print(line_end);
}
extern fn print_nl ();
extern fn exit (code: Int = 0);
extern fn input (prompt: Str = "", buffer_size: Int = 1000) Str;