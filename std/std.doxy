class Void;

primitive Char {
    fn == (self, other: Char) Bool {
    	return #asm(Bool, "
			mov rax, qword [rbp + 16]
			cmp rax, qword [rbp + 24]
			sete al
			push rax
    	")
    }
    fn != (self, other: Char) Bool {
        return !(self == other)
    }

    extern fn as_int (self) Int,
    fn str (self) Str {
    	return #asm(Str, "
			push 16
			call _$_allocate
			add rsp, 8

			mov rdi, qword [rbp + 16]
			mov qword [rax], rdi
			push rax
    	")
    }

    extern fn from_int (i: Int) Char,
}

primitive Bool {
    extern fn || (self, other: Bool) Bool,
    extern fn && (self, other: Bool) Bool,

    fn str (self) Str {
        if self {
            return "true"
        }
        return "false"
    }
}

primitive Int {
    fn + (self, n: Int) Int {
    	return #asm(Int, "
    	    mov rax, qword [rbp + 16]
            add rax, qword [rbp + 24]
            push rax
    	")
    }
    fn - (self, n: Int) Int {
		return #asm(Int, "
			mov rax, qword [rbp + 16]
			sub rax, qword [rbp + 24]
			push rax
		")
    }
    extern fn *  (self, n: Int) Int,
    extern fn /  (self, n: Int) Int,
    extern fn %  (self, n: Int) Int,
    extern fn == (self, n: Int) Bool,
    extern fn != (self, n: Int) Bool,
    extern fn <  (self, n: Int) Bool,
    extern fn <= (self, n: Int) Bool,
    fn > (self, n: Int) Bool {
		return #asm(Bool, "
			xor rax, rax
			mov rcx, qword [rbp + 16]
			cmp rcx, qword [rbp + 24]
			setg al
			push rax
		")
	}
    extern fn >= (self, n: Int) Bool,

    fn max (self, other = 9223372036854775807) Int {
        if self > other {
            return self
        }
        return other
    }

    fn min (self, other = -9223372036854775807 - 1) Int {
        if self < other {
            return self
        }
        return other
    }

    fn abs (self) Int {
        if self < 0 {
            return -self
        }
        return self
    }

    fn str (self) Str {
    	// https://stackoverflow.com/questions/8257714
    	return #asm(Str, "
    			; allocate string
                push 64 ; much larger than needed
                call _$_allocate
                add rsp, 8

                mov r15, rax ; save char*
                ; write string to allocated memory using
                ; `sprintf(buf, \"%lld\", n)`
                mov rdi, rax
                mov rsi, _$_sprintf_Int_str
                mov rdx, qword [rbp + 16]
                mov rax, 0
                mov rcx, rsi
                mov r8, 0
                mov r9, 0

                push rbp
                mov rbp, rsp
                sub rsp, 32
                and rsp, -16
                call sprintf WRT ..plt
                mov rsp, rbp
                pop rbp

                mov rax, r15

                push rax
                call Str.from_utf8
                pop rdi
                push rax
    	")
    }
}

class Str {
    fn == (self, other: Str) Bool {
    	return #asm(Bool, "
			mov r14, qword [rbp + 16] ; r14 = lhs
			mov r13, qword [rbp + 24] ; r13 = rhs

			xor rax, rax ; rax = 0 (index)

			.loop:
				mov rcx, qword [r14 + rax * 8] ; lhs[rax]
				mov rdx, qword [r13 + rax * 8] ; rhs[rax]
				cmp rcx, rdx ; lhs[rax] != rhs[rax]
				jne .not_equal

				test rcx, rcx ; lhs[rax] == 0
				jz .are_equal ; lhs[rax] == rhs[rax] == 0

				inc rax ; rax++

				jmp .loop

			.are_equal:
				mov rax, 1
				mov rsp, rbp
				pop rbp
				ret

			.not_equal:
				xor rax, rax
				push rax
		")
    }
    fn != (self, other: Str) Bool {
		return !(self == other)
    }

    /// returns a new string that is the concatenation of lhs and rhs
    fn + (self, other: Str) Str {
    	return #asm(Str, "
    		times 3 push 0             ; space for length of self and other,
                                       ; and the new string
            push qword [rbp + 16]      ; self
            call Str.len
            add rsp, 8
            mov qword [rbp - 8], rax   ; [rbp - 8] = self.len()

            push qword [rbp + 24]      ; other
            call Str.len
            add rsp, 8
            mov qword [rbp - 16], rax  ; [rbp - 16] = other.len()

            add rax, qword [rbp - 8]   ; rax = other.len() + self.len()
            inc rax                    ; rax = lhs.len() + rhs.len() + 1 (for null terminator)
            imul rax, 8                ; rax = (lhs.len() + rhs.len() + 1) * 8
            push rax
            call _$_allocate           ; rax = malloc((lhs.len() + rhs.len() + 1) * 8)
            add rsp, 8
            mov qword [rbp - 24], rax  ; [rbp - 24] = new string

            mov rdx, qword [rbp - 8]   ; rcx = self.len()
            imul rdx, 8                ; rcx = self.len() * 8
            mov rsi, qword [rbp + 16]  ; rsi = self
            mov rdi, qword [rbp - 24]  ; rdx = new string

            push rbp
            mov rbp, rsp               ; stack is 16-byte aligned
            sub rsp, 32
            and rsp, -16
            call memcpy WRT ..plt      ; memcpy(new string, self, self.len() * 8)
            mov rsp, rbp
            pop rbp

            mov rdx, qword [rbp - 16]  ; rcx = other.len()
            imul rdx, 8                ; rcx = other.len() * 8
            mov rsi, qword [rbp + 24]  ; rsi = other
            mov rdi, qword [rbp - 24]  ; rdx = new string
            mov rax, qword [rbp - 8]   ; rax = other.len()
            imul rax, 8                ; rax = other.len() * 8
            add rdi, rax               ; rdx = new string + other.len() * 8

            push rbp
            mov rbp, rsp               ; stack is 16-byte aligned
            sub rsp, 32
            and rsp, -16
            call memcpy WRT ..plt      ; memcpy(new string, other, other.len() * 8)
            mov rsp, rbp
            pop rbp

            mov rax, qword [rbp - 24]  ; rax = new string
            push rax
    	")
    }

    fn at (self, i: Int) Char {
    	return #asm(Char, "
			mov rdx, qword [rbp + 16] ; pop string
			mov r15, qword [rbp + 24] ; pop index

			cmp r15, 0
			jl .backwards

			xor rax, rax ; character
			xor rcx, rcx ; index

			.loop:
				mov rax, qword [rdx]
				test rax, rax
				je .end
				add rdx, 8

				cmp rcx, r15
				jge .end

				inc rcx
				jmp .loop

			.backwards:
				neg r15
				mov r14, rdx

				push rdx
				call Str.len
				pop rdx
				imul rax, 8
				add rdx, rax ; rdx = end of string + 1

				imul r15, 8
				sub rdx, r15 ; rdx = end of string - index
				cmp rdx, r14 ; if rdx < r14, index is out of bounds
				jl .end_and_clear

				mov rax, qword [rdx]
				jmp .end

			.end_and_clear:
				xor rax, rax
			.end:
				push rax
    	")
    }

    /// Returns the character at the given index
    /// Does not check if index is out of bounds
    fn at_raw (self, i: Int) Char {
    	return #asm(Char, "
			mov rdx, qword [rbp + 16]  ; self
			mov r15, qword [rbp + 24]  ; index

			mov rax, qword [rdx + r15 * 8]
			push rax
    	")
    }

    fn concat (self, other: Str) Str {
        return self + other
    }

    fn contains (self, other: Str) Bool {
        return self.find(other) >= 0
    }

    fn find (self, other: Str) Int {
        if other.len() == 0 {
            return 0
        }
        let mut i = 0;
        while i < self.len() {
            if self.at(i) == other.at(0) {
                let mut j = 1;
                while j < other.len() && self.at(i + j) == other.at(j) {
                    j = j + 1;
                }
                if j == other.len() {
                    return i
                }
            }
            i = i + 1
        }
        return -1
    }

    fn len (self) Int {
    	return #asm(Int, "
			mov rdx, qword [rbp + 16] ; pop string

			xor rax, rax ; string length

			; find length of string
			_$_Str.len_find_length:
				mov rcx, qword [rdx]
				test rcx, rcx
				je _$_Str.len_end
				inc rax
				add rdx, 8
				jmp _$_Str.len_find_length

			_$_Str.len_end:
				push rax
    	")
    }

    fn repeat (self, n: Int) Str {
        if n < 1 {
            return ""
        }
        // TODO: helper function in assembly to do this without allocating
        //       a new string each time through the loop
        return self + self.repeat(n - 1)
    }

    fn str (self) Str {
        return self
    }

    fn substr (self, start = 0, end = 9223372036854775807) Str {
            // TODO: give the end a proper default value.
            // This will work in all cases (end = 2^63-1 = max Int),
            // but it's not pretty.
        if self.len() < 1 {
            return ""
        }
        if end < 0 {
            return self.substr(start, Int.max(self.len() + end, 0))
        }
        if start < 0 {
            return self.substr(Int.max(self.len() + start, 0), end)
        }
        if start >= end {
            return ""
        }
        let actual_end = Int.min(self.len(), end);
        let mut i = Int.max(start, 0);
        let mut s = "";
        while i < actual_end {
            // use Str.at_raw here as bounds checking has already been done
            // and we don't want to do it again every iteration
            s = s + self.at_raw(i).str();
            i = i + 1
        }
        return s
    }

    fn starts_with (self, other: Str) Bool {
        if other.len() > self.len() {
            return false
        }
        let mut i = 0;
        while i < other.len() {
            if self.at(i) != other.at(i) {
                return false
            }
            i = i + 1
        }
        return true
    }

    fn ends_with (self, other: Str) Bool {
        if other.len() > self.len() {
            return false
        }
        let mut i = 0;
        while i < other.len() {
            if self.at(self.len() - i - 1) != other.at(other.len() - i - 1) {
                return false
            }
            i = i + 1
        }
        return true
    }

    fn reversed (self) Str {
        let mut i = 0;
        let mut s = "";
        while i < self.len() {
            s = self.at(i).str() + s;
            i = i + 1
        }
        return s
    }

    fn replace (self, search: Str, replace_with = "", max = -1) Str {
        if search.len() == 0 {
            return self
        }
        if max == 0 {
            return self
        }
        let mut i = 0;
        let mut s = "";
        let mut replacements = 0;
        while i < self.len() {
            if self.at(i) == search.at(0) {
                let mut j = 1;
                while j < search.len() && self.at(i + j) == search.at(j) {
                    j = j + 1;
                }
                if j == search.len() {
                    s = s + replace_with;
                    i = i + j;
                    replacements = replacements + 1;
                    if max >= 0 && replacements >= max {
                        s = s + self.substr(i);
                        break
                    }
                    continue
                }
            }
            s = s + self.at(i).str();
            i = i + 1
        }
        return s
    }

    fn insert (self, index: Int, other: Str) Str {
        if index < 0 {
            return self.insert(self.len() + index + 1, other)
        }
        if index >= self.len() {
            return self + other
        }
        return self.substr(0, index) + other + self.substr(index)
    }

    fn remove (self, index: Int, count = 1) Str {
        if index < 0 {
            if self.len() + index < 0 {
                return self.substr(self.len() + index + count)
            }
            return self.remove(self.len() + index, count)
        }
        if index >= self.len() {
            return self
        }
        if count < 1 {
            return self
        }
        return self.substr(0, index) + self.substr(index + count)
    }

    fn utf8_size (self) Int {
    	return #asm(Int, "
			mov r15, qword [rbp + 16]

			push r15
			call Str.len
			pop r15

			mov rdx, rax ; rdx = number of characters
			imul rdx, 8  ; rdx = index of last byte
			add rdx, r15 ; rdx = pointer to last byte

			xor rax, rax
			dec r15
			.loop:
				inc r15
				cmp r15, rdx
				jg .end
				cmp byte [r15], 0
				je .loop
				inc rax
				jmp .loop

			.end:
				push rax
    	")
    }

    /// converts utf8 to utf64, the encoding used by Str
    fn from_utf8 (utf8: Str) Str {
		// https://stackoverflow.com/questions/1543613
    	return #asm(Str, "
			mov r15, qword [rbp + 16] ; utf8
			xor r13, r13              ; number of chars in utf8

			; count number of chars in utf8
			._$_find_chars_loop:
				xor rax, rax
				mov al, byte [r15]

				cmp al, 0
				je ._$_find_chars_end

				mov cl, al
				shr cl, 7          ; if the first bit of the char is 0,
				cmp cl, 0          ; then it is a single byte char
				je ._$_1_byte_char ; otherwise, it is a multi-byte char

				mov cl, al         ; 2-byte char starts with 110x xxxx
				shr cl, 5
				cmp cl, 6
				je ._$_2_byte_char

				mov cl, al         ; 3-byte char starts with 1110 xxxx
				shr cl, 4
				cmp cl, 14
				je ._$_3_byte_char
				; jmp ._$_4_byte_char ; 4-byte char starts with 1111 0xxx
				; _$_4_byte_char:
					xor rcx, rcx
					mov cl, byte [r15+3]
					shl rcx, 8
					mov cl, byte [r15+2]
					shl rcx, 8
					mov cl, byte [r15+1]
					shl rcx, 8
					mov cl, byte [r15]
					inc r13
					push rcx
					add r15, 4
					jmp ._$_find_chars_loop

				._$_3_byte_char:
					xor rcx, rcx
					mov cl, byte [r15+2]
					shl rcx, 8
					mov cl, byte [r15+1]
					shl rcx, 8
					mov cl, byte [r15]
					inc r13
					push rcx
					add r15, 3
					jmp ._$_find_chars_loop

				._$_2_byte_char:
					xor rcx, rcx
					mov cl, byte [r15+1]
					shl rcx, 8
					mov cl, byte [r15]
					inc r13
					push rcx
					add r15, 2
					jmp ._$_find_chars_loop

				._$_1_byte_char:
					push rax
					inc r13
					inc r15
					jmp ._$_find_chars_loop

			._$_find_chars_end:

				; put the string (currently on stack) into a heap allocated array
				push r13 ; save r13 = num characters

				mov rdi, r13
				add rdi, 64 ; add space for null terminator
				imul rdi, 8
				push rdi
				call _$_allocate
				add rsp, 8
				; rax = return value (pointer to heap allocated char*)

				pop r13 ; restore r13

			._$_move_loop:
				cmp r13, 0
				jle ._$_move_return
				dec r13
				pop rdx
				mov qword [rax + r13 * 8], rdx
				jmp ._$_move_loop

			._$_move_return:
				push rax
    	")
    }
}

class Time {
	seconds: Int,
	microseconds: Int,

	fn - (self, other: Time) Time {
	    let self_micros = self.seconds * 1000000 + self.microseconds;
	    let other_micros = other.seconds * 1000000 + other.microseconds;
	    let diff_micros = self_micros - other_micros;
	    return new Time {
	        seconds: diff_micros / 1000000,
	        microseconds: diff_micros % 1000000
	    }
	}

	fn + (self, other: Time) Time {
	    let self_micros = self.seconds * 1000000 + self.microseconds;
	    let other_micros = other.seconds * 1000000 + other.microseconds;
	    let sum_micros = self_micros + other_micros;
	    return new Time {
	        seconds: sum_micros / 1000000,
	        microseconds: sum_micros % 1000000
	    }
	}

	fn str (self) Str {
		return self.seconds.str() + "." + self.microseconds.str()
	}

	extern fn current_seconds () Int,
	extern fn current_microseconds () Int,

	fn now () Time {
		return new Time {
			seconds: Time.current_seconds(),
			microseconds: Time.current_microseconds()
		}
	}

	fn epoch () Time {
		return new Time {
			seconds: 0,
			microseconds: 0
		}
	}
}

class Option <TOption> {
	value: Ptr<TOption>,

	fn none () Option<TOption> {
		return new Option <TOption> {
			value: new Ptr<TOption>
		}
	}
	fn some (value: TOption) Option<TOption> {
		return new Option <TOption> {
			value: new Ptr<TOption>.make_from(value)
		}
	}

	fn is_some (self) Bool {
		return !self.is_none()
	}

	fn is_none (self) Bool {
		return self.value.is_null()
	}

	fn unwrap (self, err_message = "Unwrapping None Option") TOption {
		if self.is_none() {
			panic(err_message)
		}
		return self.value.unwrap()
	}
}

class Any <TAny, TAnyCmp> {
	val: TAny,
	extern fn eq (self, other: TAnyCmp) Bool,
	extern fn str (self) Str,
}

primitive Ptr <TPtr> {
	fn is_null (self) Bool {
		return new Any <Ptr<TPtr>, Int> {
			val: self
		}
			.eq(0)
	}

	extern fn make_from (self, val: TPtr) Ptr<TPtr>,
	extern fn unwrap (self) TPtr,
}

class List <TList> {
	// address of first element
	head: Ptr<TList>,
	// number of bytes required to store list
    size: Int,

	fn len (self) Int {
		// number of elements in list is size of list
		// divided by size of each element,
		// which is always 8 bytes
		return self.size / 8
	}
    fn at (self, i: Int) Option<TList> {
    	if i < 0 {
    		return self.at(self.len() + i)
		}
		if i < 0 || i >= self.len() {
			return new Option<TList> {
				value: new Ptr<TList>
			}
		}
		return new Option<TList> {
			value: new Ptr<TList>.make_from(self.at_raw(i))
		}
    }
    extern fn at_raw (self, i: Int) TList,
    extern fn push (self, value: TList),
}

fn exit (code: Int = 0) {
	#asm "
		mov rax, 60
		mov rdi, qword [rbp + 16]
		syscall
	"
}

/// Reads from stdin until a newline is reached
/// allocates string to heap to fit input
/// returns pointer to string in rax
fn input (prompt: Str = "", buffer_size: Int = 1000) Str {
	return #asm(Str, "
		push qword [rbp + 16]
		call print
		pop rax

		mov rdi, qword [rbp + 24] ; buffer_size
		add rdi, 1                ; add space for null byte
		push rdi
		call _$_allocate
		add rsp, 8
		mov r15, rax              ; r15 = string pointer

		mov rax, 0
		mov rdi, 0
		mov rsi, r15
		mov rdx, qword [rbp + 24]
		syscall

		; remove trailing new line, and null terminate
		mov rax, r15
		add rax, qword [rbp + 24]
		inc rax
		.last_char_loop:
			dec rax
			cmp byte [rax], 0
			je .last_char_loop
			cmp byte [rax], 10
			je .del_last_char
			cmp byte [rax], 13
			je .del_last_char
			jmp .last_char_after_loop

		.del_last_char:
			mov byte [rax], 0
		.last_char_after_loop:

		push r15
		call Str.from_utf8 ; convert to string
						   ; this is necessary because the string
						   ; comes in as utf8, but the internal
						   ; string representation is 'utf64'
						   ; (utf8 with padding on each char up to 64 bits)
		pop r15
		push rax
	")
}
fn print (msg: Str) {
	#asm "
	    mov rsi, qword [rbp+16] ; pop string
        mov rax, rsi            ; copy string pointer

        xor rdx, rdx            ; string length

        ; find length of string
        _$_print_find_length:
            mov rcx, qword [rax]
            test rcx, rcx
            je _$_print_end_length
            inc rdx
            inc rax
            jmp _$_print_find_length

        _$_print_end_length:
            mov rax, 1
            mov rdi, 1
            syscall
	"
}

fn println (msg: Str, line_end="\n") {
    print(msg);
    print(line_end);
}
fn panic (msg: Str) {
	println("PANIC: '" + msg + "'");
	exit(1);
}