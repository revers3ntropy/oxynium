#!/bin/bash

GREEN="\033[0;32m"
RED='\033[0;31m'
NC='\033[0m'

fails=0
tests=0

current_spec_name=""
current_spec_num_tests=0
current_spec_has_failed=0
current_spec_file=""
tests_started=0

function setup () {
  cargo build -r
  bin/compile_std
}

function describe () {
    if [ $tests_started -eq 1 ]; then
        if [ "$current_spec_has_failed" -eq 0 ]; then
            printf "${GREEN}✔ %s${NC}\n" "$current_spec_name"
        fi
    fi
    current_spec_name="$1"
    current_spec_num_tests=0
    current_spec_has_failed=0
    tests_started=1
}

function execute() {
    code="$1"

    {
        rm ./out.asm
        rm ./out.o
        rm ./out
    } 2> /dev/null

    errors=$({
      # compile, link and assemble the program
      echo "$code" > in.oxy

      export RUST_BACKTRACE=1
      ./target/release/oxynium --std std.asm in.oxy
    } 2>&1 > /dev/null)

    if [ "$errors" != "" ]; then
        echo "$errors"
        return 0
    fi

    output="BASH_ERROR_NOT_ASSIGNED"
    if test -f "./out"; then
        # remove any \0 characters from output
        # stops 'warning: command substitution: ignored null byte in input'
        output=$(./out | tr -d '\000')
    else
        output="ERROR_NO_OUTPUT"
    fi

    output=$(echo "$output" | tr -d '\n')
    echo "$output"
}

function test_failed() {
    code="$1"
    expected="$2"
    output="$3"
    fails=$((fails+1))

    if [ "$current_spec_has_failed" -eq 0 ]; then
        echo -e "${RED}❌ $current_spec_name ($current_spec_file)${NC}"
    fi
    current_spec_has_failed=1

    # shellcheck disable=SC2059
    printf "${RED}#${current_spec_num_tests}${NC}\n"
    printf "    Executing: '%s'\n" "$code"
    printf "    Expected:  '%s'\n" "$expected"
    printf "    Got:       '%s'\n\n" "$output"
    if [ "$errors" != "" ]; then
        printf "    Errors:   '%s'\n\n" "$errors"
    fi
}

function expect() {
    code="$1"
    expected="$2"

    tests=$((tests+1))
    current_spec_num_tests=$((current_spec_num_tests+1))

    output=$(execute "$code")
    # replace \r with \r\n in expected
    expected=$(echo "$expected" | tr '\r' '\n')
    output=$(echo "$output" | tr '\r' '\n')

    if [ "$output" != "$expected" ]; then
        test_failed "$code" "$expected" "$output"
    fi
}

function expect_err() {
    code="$1"
    expected="$2"

    tests=$((tests+1))
    current_spec_num_tests=$((current_spec_num_tests+1))

    output=$(execute "$code")
    split_arr=(${output//:/ })
    output_err="${split_arr[0]}"

    if [ "$expected" != "$output_err" ]; then
        test_failed "$code" "Error: '$expected'" "$output"
    fi
}

function expect_expr_int() {
    code="$1"
    expected="$2"
    expect "print_int($code)" "$expected"
}

function expect_expr_bool() {
    code="$1"
    expected="$2"
    expect "print_bool($code)" "$expected"
}

function results() {

    if [ "$fails" -eq 0 ]; then
        # shellcheck disable=SC2059
        printf "${GREEN}  ${tests}/${tests} tests passed!${NC}\n"
        exit 0
    else
        # shellcheck disable=SC2059
        printf "${RED}  ${fails}/${tests} tests failed${NC}\n"
        exit 1
    fi
}

start=$(date +"%s.%3N")

setup

for f in ./spec/*; do
  current_spec_file="$f"
  # shellcheck disable=SC1090
  source "$f";
done

# show last 'all passing' message
describe ""

end=$(date +"%s.%3N")
runtime=$(echo "$end - $start" | bc -l)
echo "Tests ran in $runtime s"

results
